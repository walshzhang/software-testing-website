# 1 基本概念

[toc]

## 1.1 错误、故障、失效

### 1.1.1 错误（Error）

* 人都会做错事。错误是我们生活中的一部分
  * 医生不正确使用抗生素
  * 歌手在唱歌时跑调
  * 程序员使用了错误的语法，如if(a=3)
* 错误可大可小。严重的错误可导致严重的后果
  * 2015年8月12日，天津8.12爆炸。重大安全责任事故
  * 千年虫问题，工资系统数据溢出。73, 74, 。。。，98，99，00
  * 1996年6月5日，Ariane 5火箭爆炸（定位系统出错）
* 编程时出现的错误称为Bug
  * “Bug”的由来：Grace Murray Hopper，电子管，飞蛾
  * [格蕾丝·赫柏_百度百科](https://baike.baidu.com/item/格蕾丝·赫柏/5361749)：1906年12月9日~1992年1月1日
    * Cobol语言之母
    * 耶鲁大学第一位女博士

### 1.1.2 故障（Fault）、失效（Failure）

* 故障：错误的后果或具体的表现形式

  * 12306：服务器带宽不够
  * 编程时发生的故障称为缺陷（Defect）

* 失效：发生故障会导致失效，或者说故障引起的后果

  * 无法处理过量的用户请求
  * 执行有故障的代码时会引起失效

* 故障的严重程度

  ![](/images/故障严重程度.png)

* 缺陷的修复成本

  ![](/images/缺陷修复成本.png)

* 程序员错误地理解了需求，从而写出了不正确的（有故障的）代码，在执行时，其行为与预期的行为不一致（失效）

* 本课程主要使用缺陷和Bug这两个词

## 1.2 软件质量

* 静态软件质量：结构化的，可维护的，可测试的代码及正确并且完整的文档
* 动态软件质量：软件可靠性、正确性、完整性、一致性、易用性和性能
  * 可靠性：（给定时间段或给定条件下）软件无失效地运行的概率
  * 正确性：对于所有的（合法与不合法）测试输入，程序的实际行为与预期行为保持一致
  * 完整性：全部得到需求规格说明或用户手册中所有功能的可能性。一个不完整的软件是没有完全实现所有规定功能的软件
  * 一致性：软件对常规惯例和假设遵循的程度。例如，所有的按钮遵循统一的样式（颜色、形状等）
  * 易用性：使用软件的难易程度
  * 性能：软件完成规定任务所花费的时间

## 1.3 需求、输入域、正确性

* 需求定义了软件预期完成的功能
* 需求应该是完整的和无歧义的
  * 需求1：编写程序max，输入两个整数，输出其中的最大者
  * 需求2：编写程序sort，输入一个整数序列，输出排序后的整数序列
* 对软件所有可能输入都进行的测试称为穷举测试。**穷举测试是不可能的**
* 输入域：软件P所有可能输入的集合。也称为输入空间
  * max程序的输入域是所有整数对的集合。每个整数的取值范围为−2^31~2^31−1
  * sort程序的输入域是？需要去除需求中歧义，升序或降序？
    * 输入一个整数序列，输出排序后的整数序列。当输入选择参数为A时，按升序排列，为D时，按降序排列。在向程序输入数据时，首先指定选择参数，然后输入待排整数序列，整数序列以点结束

## 1.4 测试（Test）

* 判断人们在思考、行动及其产生的产品中是否存在错误
  * 教师安排一次测试，检查学生掌握所学内容的程度（想法）
  * 教练进行一次测试，检查球员的动作是否规范（动作）
  * 软件开发人员进行一次测试，检查登录功能是否正常（软件产品）
* 测试的目的：判断人们的想法、行动及产品是否满足预期要求
* 软件测试：**发现软件当中存在的错误**
  * 语义错误和语法错误
  * 语法错误可通过编译器进行检查
  * 软件测试主要考虑语义错误
* 软件测试**不能证明软件的正确性**
* 本课程只讨论软件测试
* 五个关键问题
  * 谁来执行测试（Who）
    * 开发人员（Developer）
    * 测试人员（Tester）
  * 测什么（What）
    * 整个软件
    * 主要包括文档，代码
  * 什么时候测试（When）
    * 尽早进行
    * 与开发并行（敏捷开发）
  * 怎样进行测试（How）
    * 测试用例
    * 软件过程模型
  * 测试标准
    * **完全测试不可能**
    * 覆盖率/错误检出率/发现的错误数量

* 确定错误原因并纠正错误的过程称为**调试**（Debug）

* 测试过程是在**测试计划**（Test Plan）指导下完成

* 测试计划体现为一组**测试需求**（Test Requirement）

  * sort程序应满足如下3条测试需求：
    * 至少执行两个输入序列，分别以A和D作为选择参数
    * 执行一个空的输入序列
    * 以错误的输入测试其健壮性，如以R作为其选择参数

* **测试用例**（Test  Case）主要由输入（也称测试数据）和预期输出构成

  * 每条用例应覆盖至少一条测试需求
  * sort程序的测试用例

  | 编号 | 测试数据        | 预期结果     | 覆盖测试需求 |
  | ---- | --------------- | ------------ | ------------ |
  | TC1  | <A 12 -29 32 .> | -29 12 32    | 1            |
  | TC2  | <D 12 -29 32 .> | 32 12 -29    | 1            |
  | TC3  | <A .>           | 没有输出     | 2            |
  | TC4  | <D .>           | 没有输出     | 2            |
  | TC5  | <R 3 17 .>      | 无效选择参数 | 3            |
  | TC6  | <A c 17 .>      | 无效数字     | 3            |

## 1.5 测试用例生成策略

* 设计测试用例是测试活动中最重要的任务
* 测试人员严格按照测试用例执行测试
* 生成策略：如何设计测试用例
  * 基于需求的测试生成策略：从需求文档中生成测试用例
    * 非形式化：等价类/边界值/随机测试
  * 基于代码的测试生成策略：从代码中生成测试用例
    * 控制流/数据流/程序变异
  * 基于模型的测试生成策略：将系统形式化为模型并生成测试用例
    * 形式化：状态机/自动机/Petri网/时间自动机

## 1.6  测试分类

* 是否需要手工测试
  * 手工测试
  * **自动化测试**

* 是否需要执行被测软件？
  * **静态测试**：不需要执行程序。只针对源代码与文档
    * 审查：审查进度/代码/需求/设计/…
    * 静态代码分析工具：找出代码中隐藏的错误和缺陷
      * CheckStyle：检查编码规范
      * FindBugs：发现代码中潜在的错误。如错误的递归，可能出现的空指针引用等
  * **动态测试**：需要执行程序

* 测试生成的依据
  * 需求文档（非形式化的）：属于**黑盒测试**
    * 黑盒测试：只根据需求文档设计测试用例的方法。也称功能测试
    * 试探法/边界值分析/因果图/等价类划分/随机测试/….
  * 形式化模型：属于**基于模型的测试**
    * 基于模型的测试：使用形式化后的需求设计测试用例的方法。本质上也属于黑盒测试
    * 状态图测试/FSM测试/…
  * 源代码：属于**白盒测试**
    * 白盒测试：只使用源代码设计测试用例的方法。需要与黑盒测试联合使用。也称结构测试
      覆盖测试/数据流测试/路径测试/…
    * **白盒测试和黑盒测试都属于动态测试**
* 测试所在的生命周期阶段
  * 编码：**单元测试**。测试单个模块
  * 集成：**集成测试**。测试多个模块
  * 系统集成：**系统测试**。测试整个系统，包括功能与非功能测试，包含硬件环境
  * 维护：**回归测试**。修改软件后的测试
  * 预发布：
    * **验收测试**：用户在验收时进行的测试
      * **α测试**：在开发人员的场所进行的验收测试
      * **β测试**：由用户组织在用户的场所进行的测试
* 具体测试活动的目标
  * **性能测试**（Performance Test）：为获取或验证系统性能指标而进行测试
    * 春运期间，每秒种能支持40,0000次查询余票请求
  * **压力测试**（Stress Test）：在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等
  * **负载测试**（Load Test）：通过改变系统负载方式、增加负载等来发现系统中所存在的性能问题。负载测试是一种测试方法，可以为性能测试、压力测试所采用。
  * 安全测试/兼容性测试/国际化测试/Web应用测试/移动应用测试/界面测试/扩展性测试/…

