# 4 基于代码的测试

[TOC]

* 需求不可能包含所有实现的细节
* 需求没有提及但实现时应该考虑的细节
* 对于极其重要的软件，如航空航天系统，必须对实现的细节进行测试

## 4.1 控制流图

* **基本块**：一个顺序的语句序列，只有一个入口点和一个出口点

* 基本块例子

  * 为什么 1 号基本块到第第 5 行结束？
  * 为什么第 10 行 while 语句构成一个基本块？
  * 第 1，17，7，13 行被忽略
  * 为什么第 16 行单独构成基本块？

  ![](/images/基本块.png)

* **控制流图**：描述程序中的控制流，也称**流图**。$G=(N,E)$，$N$ 表示图中节点的集合，每个结点对应一个基本块。$E$ 表示边的集合，每条边表示基本块之间的控制流。边 $(i,j)$ 表示从基本块 $N_i$ 到 $N_j$ 的控制流

* 流图中没有入边的结点称为**起始结点**，没有出边的结点称为**终止结点**

* 控制流图例子

  <img src="/images/控制流图.png" style="zoom:50%;" />

* 考虑流图 $G=(N,E)$。假设 $n_p,n_q,n_r,n_s$ 是 $N$ 中的结点，对任意 $0<i<k$，如果有 $e_i=(n_p,n_q )$ 且 $e_(i+1)=(n_r,n_s)$，则 $n_q=n_r$，则此 $k$ 条边序列 $(e_1,e_2,⋯,e_k)$ 是一条长度为 $k$ 的**路径**

* 对于任何 $n,m∈N$，如果存在一条从 $n$ 到 $m$ 的路径，则称 $m$ 是 $n$ 的**后继**，或称 $n$ 是 $m$ **前驱**。若 $m \neq n$，则 $m$ 是 $n$ 的**真后继**，$n$ 是 $m$ 的**真前驱**。如果存在 $(n,m) \in E$，则称 $m$ 是 $n$ 的**直接后继**，$n$ 是 $m$ 的**直接前驱**。结点 $n$ 的直接前驱和直接后继分别记为 $prev(n)$ 和 $succ(n)$。起始结点没有前驱，终止结点没有后继。如果存在循环，结点可为自身的前驱和后继

* 流图中的一条路径，如果其首结点为**起始结点**，末结点为**终止结点**，则称该路径是**完整**的。

* 流图中的一条路径 $p$，如果至少存在一条测试用例，其在执行程序时能够遍历 $p$，则称 $p$ 是可达的，否则称其是不可达的

* 路径例子
  * $((1,3),(3,4),(4,5))$ 是一条长度为 4 的路径
  * 但 $((1,3),(3,5),(6,8))$不构成路径
  * 两条完整可达路径
    * $(Start,1,2,4,5,6,5,7,9,End)$
    * $(Start,1,3,4,5,6,5,7,8,9,End)$

## 4.2 测试充分性

* 假设软件 $P$ 要满足功能需求集合 $R$，记为 $(P,R)$。$R$ 中包含 $n$ 个需求，记为 $R_1,R_2,⋯,R_n$。再假设测试集 $T$ 包含了 $k$ 个测试用例用于确认 $P$ 是否满足 $R$ 中的所有需求，并假设 $T$ 中的每个用例都执行成功
* "**充分性**“用来度量一个给定的测试集是否能验证软件 $P$ 满足其需求。当测试集满足测试准则 $C$ 时，即认为其相对于 $C$ 是充分的
* 例1：考虑编写程序 $P$，其需求 $R$ 如下：
  * $R_1$: 从键盘输入两个整数 $x$ 和 $y$
  * $R_{2.1}$: 当 $x<y$ 时，求 $x$ 和 $y$ 之和，并在屏幕上输出
  * $R_{2.2}$: 当 $x \geq y$ 时，求 $x$ 和 $y$ 之积，并在屏幕上输出
* **需求覆盖**：如果针对 $R$ 中的每个需求 $r$，测试集 $T$ 中至少有一个用例能够证明 $P$ 满足 $r$，则认为 $T$ 对于 $(P,R)$ 是充分的
* **覆盖域**：用于度量测试集充分性的有限集。每个测试准则都可导出一个覆盖域
* 假设要度量测试集 $T$ 的充分性。给定覆盖域 $C_e$，它有 $n≥0$ 个元素。如果 $C_e$ 中的每个元素 $e$，在 $T$ 中都至少有一个测试用例能够测试它，则称 $T$ 覆盖 $e$。如果 $T$ 能覆盖 $C_e$ 中的所有元素，称 $T$ 对于 $C_e$ 是充分的。如果 $T$ 只能覆盖 $C_e$ 中的 $k \leq n$ 个元素，称 $T$ 对于 $C_e$ 是不充分的。比率 $k/n$ 代表 $T$ 对于 $C$ 的充分度，也称 $T$ 对于 $C,R,P$ 的**覆盖率**
* 例2：考虑例 1 中的 $P,R,C$，令 $T = \{ \langle x = 3, y = 4 \rangle \}, C_e=\{R_1,R_{2.1},R_{2.2}\}$. 此时 $T$ 覆盖 $R_1$ 和 $R_{2.1}$，但没覆盖 $R_{2.2}$。因此 $T$ 对于 $C_e$ 是不充分的，覆盖率为 $2 / 3$
* 例3：例 1 中的 $P$ 所对应的代码有两条路径 $p_1$ 和 $p_2$，分别对应条件 $x<y$ 和 $x \geq y$. $T$ 对于路径覆盖准则不充分，其只能覆盖 $p_1$，因此覆盖率为 $0.5$

* **路径覆盖准则：**如果程序 $P$ 中的每条路径都被遍历至少一次，则认为测试集 $T$ 针对 $(P,R)$ 是充分的
  * 条件语句会引起路径数量的指数级增长
  * 循环的存在将极大地增加路径的数量，每循环一次，路径数量至少增加 1

## 4.3 测试增强

* 虽然测试集对于某些测试准则是充分的，但不能保证程序没有错误。不充分的测试集意味着测试不足。此时，如果能提高测试集的覆盖率，就能提高发现错误的几率，即测试增强

* 例4：例 3 中的 $T$ 对于 $C$ 的覆盖率只有 $0.5$，如果往 $T$ 中添加测试用例 $\langle x=3, y=1 \rangle$，则扩充后的测试集 $T^\prime$ 能够覆盖 $\{p_1,p_2\}$，覆盖率为 1

* 通过度量充分性来增强测试

  * 如果测试集 $T$ 对于准则 $C$ 是充分的，则无需增强，退出。否则进入下一步
  * 对每个未被覆盖的 $e∈C_e$，执行以下步骤
    * 构造测试用例 $t$，它能够覆盖 $e$，把 $t$ 加入到 $T$ 中
    * 针对 $t$ 执行 $P$，如果执行不正确，则修改 $P$，重复此步骤直到 $P$ 执行正确

* 例5：$P$ 为计算 $x^y$ 的程序。$x$ 和 $y$ 为整数。若 $y<0$，输出错误信息

  <img src="/images/测试增强1.png" style="float: left; zoom: 67%;" />

  * 测试准则 $C$：如果测试集 $T$ 对 $x$ 和 $y$ 中的每一个，至少经过一次等于 $0$ 和不等于 $0$，则 $T$ 是充分的 $C_e = \{ x = 0, y = 0, x \neq 0,y \neq 0 \}$
  * $T=\{\langle x=0,y=1 \rangle, \langle x=1,y=0 \rangle \}$ 相对于 $C$ 是充分的

* 例6：将例 5 中的测试准则替换为路径覆盖准则。由于 $while$ 语句的存在，流图中路径的个数具有不确定性，其依赖 $y$ 的值。因此其路径个数可能会非常大，此时，无法确定路径覆盖准则的覆盖域。此时，可将路径覆盖准则简化为 $C^\prime$：

  * $C^\prime$: 如果测试集 $T$ 测试了所有路径，则它是充分的。若程序包含循环，则只要 $T$ 遍历过循环体 $0$ 次和 $1$ 次即可
  * 根据 $C^\prime$，可导出 $C_e^\prime=\{p_1,p_2,p_3\}$。其中，
    * $p_1=(1,2,3,4,5,7,9)$
    * $p_2=(1,2,3,4,5,6,5,7,9)$
    * $p_3=(1,2,3,8,9)$
  * 测试增强：$T^\prime=T \cup \{\langle x=5,y=-1 \rangle \}$

## 4.4 基于控制流的测试准则

* **语句覆盖（行覆盖）**：测试集 $T$ 针对 $(P,R)$ 的语句覆盖率计算为 $\frac {\left| S_c \right|}{\left| S_e \right|-\left| S_i \right|}$。其中 $S_c$ 是所有被覆盖语句的集合，$S_i$ 是所有不可达语句的集合，$S_e$ 是软件中所有语句的集合，即语句覆盖域。如果 $T$ 针对 $(P,R)$ 的语句覆盖率为 1，则称 $T$ 相对于语句覆盖准则是充分的

  * $S_e=\{2,3,4,5,6,7,8,8b,10,11\}$                                                                          

  * $T_1 = \{t_1, t_2 \}，t_1:\langle x=-1,y=-1, z \rangle，t_2:\langle x=1,y=1, z \rangle$

  * $t_1$ 覆盖 $2,3,4,5,6,7,8,11$，$t_2$ 覆盖 $2,3,4,5,6,10,11$

  * 语句 $8b$ 失效的元素

  * $|S_e|=10,|S_i|=1,|S_c|=9$

  * $T$ 的语句覆盖率为 $9/(10-1)=1$，其在语句覆盖准则下是充分的

    ```pascal
    begin                       //1
      int x, y;         		//2
      int z;					//3
      input(x, y);				//4
      z = 0;					//5
      if (x < 0 and y < 0) {	//6
        z = x * x;				//7
        if (y >= 0) z = z + 1	//8
      }							//9
      else z = x * x * x;		//10
      output(z)					//11
    end							//12
    ```

* 条件与判定

  * 任何计算结果为 $true$ 或 $false$ 的表达式都是一个**条件**
  * **简单条件**：由变量和至多一个关系运算符构成，如布尔变量 $A$，$x>y$
  * **复合条件**：两个或多个简单条件经一个或多个布尔运算符连接而成，如 $A || x>y$
  * 作为判定的条件：包含在 $if$，$while$ 中的条件称为**判定**

* **判定覆盖（分支覆盖）**：测试集 $T$ 针对 $(P,R)$ 的判定覆盖率计算为 $\frac {|D_c |}{|D_e |-|D_i |}$。其中 $D_c$ 是所有被覆盖判定的集合，$D_i$ 是所有不可达判定的集合，$D_e$ 是软件中所有判定的集合，即判定覆盖域。如果 $T$ 针对 $(P,R)$ 的判定覆盖率为 1，则称 $T$ 相对于判定覆盖准则是充分的 

  * $T = \{t_1:\langle x=-5, y = -1, z \rangle \}$. 容易验证 $T$ 对于语句覆盖是充分的

  * 测试增强：令 $T^\prime = T \cup \{\langle x = 3, y = -1, z \rangle \}$.   从而发现错误

    ```pascal
    begin
      int x, y, z;
      input(x, y);
      if (x < 0 and y < 0)
        z = foo1(x, y);
      //else 注释掉 else 会产生错误
        z = foo2(x, y);
      output(z);
    end
    ```

* **条件覆盖**：在软件执行过程中，如果某个简单条件曾分别被计算出 $true$ 和 $false$，则称该简单条件被覆盖了。测试集 $T$ 针对 $(P,R)$ 的条件覆盖率计算为 $\frac {|C_c |}{|C_e |-|C_i |}$。其中 $C_c$ 是所有被覆盖简单条件的集合，$C_i$ 是所有不可达简单条件的集合，$C_e$ 是软件中所有简单条件的集合，即条件覆盖域。如果 $T$ 针对 $(P,R)$ 的条件覆盖率为 1，则称 $T$ 相对于条件覆盖准则是充分的。

  * $T=\{t_1,t_2\}.C_e=\{x<0, y<0 \}. C_i= \emptyset$
    * $t_1=\langle x=-3,y=-2, z \rangle$
    * $t_2=\langle x=-4,y=2, z \rangle$
    * 对于语句、判定覆盖是充分的
    * 对于条件覆盖不充分：$C_c=\{y<0\}$. 覆盖率为 $1/(2-0)=50\%$
    
  * 测试增强：令 $T^\prime = T \cup \{\langle x = 3, y = -1 \rangle \}$

    ```pascal
    begin
      int x, y, z;
      input(x, y);
      if (x < 0 and y < 0)
        z = foo1(x, y);
      else
        z = foo2(x, y);
      output(z);
    end
    ```

* **条件/判定覆盖**：测试集 $T$ 针对 $(P,R)$ 的条件/判定覆盖率计算为 $\frac {|C_c |+|D_c |}{((|C_e |-|C_i |)+(|D_e |-|D_i |))}$。其中 $C_c,D_c$ 是所有被覆盖简单条件和判定的集合，$C_i,D_i$ 是所有不可达简单条件和判定的集合，$C_e,D_e$ 是软件中所有简单条件和判定的集合。如果 $T$ 针对 $(P,R)$ 的条件/判定覆盖率为 1，则称 $T$ 相对于条件/判定覆盖准则是充分的

  * 必要性：判定覆盖不需要考虑复合条件，而条件覆盖不需要考虑判定判定的真/假路径

  * $T_1=\{\langle x=-3,y=2, z \rangle,\langle x=4, y=2, z \rangle\}$ 对于判定覆盖是充分的，但对于条件覆盖不充分

  * $T_2=\{\langle x=-3,y=2, z \rangle,\langle x=4, y=-2, z \rangle\}$ 对于条件覆盖是充分的，但对于判定覆盖不充分

  * $T=\{\langle x = -3, y = -2, z \rangle,\langle x = 4, y = 2, z \rangle\}$ 对于条件/判定覆盖充分的

    ```pascal
    begin
      int x, y, z;
      input(x, y);
      if (x < 0 or y < 0)  // 把 and 写成 or
        z = foo1(x, y);
      else
        z = foo2(x, y);
      output(z);
    end
    ```

* **多重条件覆盖（条件组合覆盖）**：测试集 $T$ 针对 $(P,R)$ 的多重条件覆盖率计算为 $\frac {|C_c |}{|C_e |-|C_i |}$。其中 $C_c$ 是所有被覆盖简单条件组合的集合，$C_i$ 是所有不可达简单条件组合的集合，$C_e$ 是软件中所有简单条件组合的集合。如果 $T$ 针对 $(P,R)$ 的多重条件覆盖率为 1，则称T相对于多重条件覆盖准则是充分的

  * 若软件中共包含 $n$ 个判定 $d_1, d_2, \cdots, d_n$，每个判定分别包含 $k_1, k_2, \cdots, k_n$ 个简单条件，则整个软件所含的简单条件组合的数量为 $\sum_{i=1}^{n}2^{k_i}$

    * 当 $k = 32$ 时，对应的组合数为 $2^{32}$，如果 1 毫秒执行其中的一种组合，执行完所有的组合需要 24.75 天
    * 对于航空航天类的软件，$k = 32$ 的情况并不少见

  * $T = \{ \langle A = 2, B = 3, C = 1 \rangle, \langle A = 2, B = 1, C = 3 \rangle, \langle A = 2, B = 3, C = 5 \rangle \}$ 对于条件/判定覆盖准则是充分的

  * 但它没有达到多重条件覆盖

    * 没有覆盖第一个判定中的 `A >= B and A > C`

  * 测试增强：$T^\prime = T \cup \{ \langle A = 2, B = 1, C = 1 \rangle \}$

    ```pascal
    begin
      int A, B, C, S = 0;
      input(A, B, C);
      if(A < B and A > C) S = f1(A, B, C);
      if(A < B and A <= C) S = f2(A, B, C);
      if(A >= B and A <= C) S = f4(A, B, C);
      output(S);
    end
    ```


## 4.5 改进的条件/判定覆盖：MC/DC

* 出发点：多重条件覆盖准则成本太高

* 考虑复合条件 $C = (C_1\ and\ C_2)\ or\ C_3$，其中 $C_1, C_2, C_3$ 都是简单条件。其对应的组合为

  | 编号 | $C_1$ | $C_2$ | $C_3$ | $C$   |
  | ---- | ----- | ----- | ----- | ----- |
  | t1   | true  | true  | true  | true  |
  | t2   | true  | true  | false | true  |
  | t3   | true  | false | true  | true  |
  | t4   | true  | false | false | false |
  | t5   | false | true  | true  | true  |
  | t6   | false | true  | false | false |
  | t7   | false | false | true  | true  |
  | t8   | false | false | false | false |

* 固定其中的两个简单条件，变化另外一个简单条件，观察 $C$ 的输出是否相同。

  * 若不同，则说明这个条件能够独立影响 $C$ 的输出，此时，可将对应的两条用例记录下来
  * 若相同，则说明不能独立影响 $C$ 的输出，此时忽略，不记录

* 以上述真值表为例

  * 固定 $C_2, C_3$，变化 $C_1$，

    * $t1$ 和 $t5$ 对应的 $C$ 的结果不同，记录
    * $t2$ 和 $t6$ 对应的 $C$ 的结果不同，记录
    * $t3$ 和 $t7$ 对应的 $C$ 的结果相同，都为 true，不记录
    * $t4$ 和 $t8$ 对应的 $C$ 的结果相同，都为 false，不记录

  * 固定 $C_1, C_2$，变化 $C_3$，

    * $t1$ 和 $t2$ 对应的 $C$ 的结果相同，都为 true，不记录
    * $t3$ 和 $t4$ 对应的 $C$ 的结果不同，记录
    * $t5$ 和 $t6$ 对应的 $C$ 的结果不同，记录
    * $t7$ 和 $t8$ 对应的 $C$ 的结果不同，记录

  * 固定 $C_1, C_3$，变化 $C_2$，

    * $t1$ 和 $t3$ 对应的 $C$ 的结果相同，都为 true，不记录
    * $t2$ 和 $t4$ 对应的 $C$ 的结果不同，记录
    * $t5$ 和 $t7$ 对应的 $C$ 的结果相同，都为 true，不记录
    * $t6$ 和 $t8$ 对应的 $C$ 的结果相同，都为 false，不记录

  * 从每个条件记录的用例中选择一组，要求所选择用例的集合最小化

    * 对于 $C_3$，因为它只记录了一组，因此必须选择 $t2$ 和 $t4$
    * 对于 $C_1$，因为 $t2$ 已经被 $C_3$ 选择，所以 $C_1$ 选择  $t2$ 和 $t6$
    * 对于 $C_2$，选择 $t3$ 和 $t4$

  * 去重后，最终选择的用例为 $\{ t2, t3, t4, t6 \}$

    | 编号 | $C_1$ | $C_2$ | $C_3$ | $C$   |
    | ---- | ----- | ----- | ----- | ----- |
    | t2   | true  | true  | false | true  |
    | t3   | true  | false | true  | true  |
    | t4   | true  | false | false | false |
    | t6   | false | true  | false | false |

* **MC覆盖**：设 $C_1, C_2, \cdots, C_n$ 是软件 $P$ 中的条件，作为判定的组成部分，每个条件既可以是简单条件，也可以是复合条件；用 $n_i$ 表示条件 $C_i$ 中简单条件的个数；用 $e_i$ 表示能够独立影响 $C_i$ 输出结果的简单条件的个数；用 $f_i$ 表示 $C_i$ 中无效简单条件的个数；用 $MC_c$ 表示满足需求 $R$ 的软件 $P$ 的测试集 $T$ 的 MC 覆盖率，其计算公式为：$MC_c = \frac {\sum_{i=1}^ne_i}{\sum_{i=1}^n(n_i-f_i)}$。如果测试集 $T$ 的 $MC_c$ 为1，则称其相对于 $MC$ 覆盖准则是充分的。
  * 对于复合条件 $C$ 中的一个简单条件，如果不能证明它对 $C$ 的输出结果有独立影响，则它是无效的简单条件

* **修正条件/判定覆盖MC/DC**（Modified Condition/Decision Coverage）：满足需求 $R$ 的软件 $P$ 的测试集 $T$ 针对 MC/DC 覆盖准则是充分的，如果对 $P$ 执行 $T$ 中的测试用例，满足如下要求：
  * 条件覆盖：$P$ 中的每一个简单条件都取过 true 和 false
  * 判定覆盖：$P$ 中的每一个判定都得出过所有可能的输出结果
  * MC覆盖：$P$ 中的复合条件 $C$ 中的每个简单条件对 $C$ 的输出结果的影响是独立的

* **如果判定中的简单条件个数为 $k$，多重条件覆盖要求组合数量为 $2^k$，MC/DC要求的组合可降为 $k + 1$ 个，两者具有几乎相同的测试效果。**

  * 当 $k = 32$ 时，测试用例个数降为 33 个，执行时间从 24.75 天缩短为 33 毫秒
  * 民航 DO-178C《机载系统合格审定过程中的软件考虑》明确指出：A级软件必须进行MC/DC测试
  * ISO 26262-6 《道路车辆功能安全》要求：A级软件必须进行MC/DC测试

## 4.5 测试准则包含关系

* 包含性：给定测试集 $T$，它针对测试准则 $C_1$ 是充分的，针对另一个测试准则 $C_2$ 是否充分？
* 路径覆盖 $\Rightarrow$ 多重条件覆盖  $\Rightarrow$ MC/DC $\Rightarrow$ 条件/判定覆盖 $\Rightarrow$ 判定覆盖 $\Rightarrow$ 语句覆盖
* 条件/判定覆盖 $\Rightarrow$ 条件覆盖
* 语句覆盖 $\nRightarrow$ 分支覆盖
* 条件覆盖 $\nRightarrow$ 判定覆盖

## 4.5 例子

```java
public class CountWords {
    // 统计给定字符串中以 s 或 r 结尾的单词的个数
    // 当出现非字母字符时，视为单词结束
    public int count(String str) {
        int words = 0;
        char last = ' ';
        int i = 0;
        
        while ( i < str.length()) {
            if (!isLetter(str.charAt(i)) && (last == 's' || last == 'r')) {
                words++;
            }
            
            last = str.charAt(i); 
            i++;
        }
        
        if (last == 'r' || last == 's') { 
            words++;
        }
        
        return words;
    }
}
```

<img src="/images/CountWords-控制流图.png" style="zoom:80%; float: left;" />

* 语句覆盖

  * 覆盖域 $C_e = \{ s1, s2, s3, s4, s5, s6, s7, s8, s9, s10 \}$

  * 覆盖率：$10/10 = 100\%$

    | 编号 | 测试用例                                                  | 覆盖元素                                  |
    | ---- | --------------------------------------------------------- | ----------------------------------------- |
    | t1   | $\langle str = 'oranges\ and\ apples', words = 2 \rangle$ | $s1, s2, s3, s4, s5, s6, s7, s8, s9, s10$ |

* 判定覆盖

  * 覆盖域 $C_e = \{ d1, d2, d3 \}$

    * $d1$：`i < str.length()`,
    * $d2$：`!isLetter(str.charAt(i)) && (last == 's' || last == 'r')`
    * $d3$：`last == 's' || last == 'r'`

  * 覆盖率：$2/3 = 67\%$

    | 编号 | 测试用例                                                  | 覆盖元素 |
    | ---- | --------------------------------------------------------- | -------- |
    | t1   | $\langle str = 'oranges\ and\ apples', words = 2 \rangle$ | $d1, d2$ |

* 条件覆盖

  * 覆盖域 $C_e = \{ c1, c2, c3, c4, c5, c6 \}$

    * $c1$：`i < str.length()`
    * $c2$：`!isLetter(str.charAt(i))`
    * $c3$：`last == 's'`
    * $c4$：`last == 'r'`
    * $c5$：`last == 'r'`
    * $c6$：`last == 's'`

  * 覆盖率：$2/6 = 33\%$

    | 编号 | 测试用例                                                  | 覆盖元素         |
    | ---- | --------------------------------------------------------- | ---------------- |
    | t1   | $\langle str = 'oranges\ and\ apples', words = 2 \rangle$ | $c1, c2, \cdots$ |

* 条件/判定覆盖

  * 覆盖域：$C_e = \{ c1, c2, c3, c4, c5, c6, d1, d2, d3 \}$

    * $c_i$ 同条件覆盖，$d_i$ 同判定覆盖

  * 覆盖率：$(2 + 2) / (6 + 3) = 44\%$

    | 编号 | 测试用例                                                  | 覆盖元素         |
    | ---- | --------------------------------------------------------- | ---------------- |
    | t1   | $\langle str = 'oranges\ and\ apples', words = 2 \rangle$ | $c1, c2, d1, d2$ |

* 多重组合覆盖

  * 覆盖域：$C_e = \{ c1, \overline{c1}, c2c3c4, \overline{c2}c3c4, c2\overline{c3}c4, \overline{c2}\overline{c3}c4, c2c3\overline{c4}, \overline{c2}c3\overline{c4}, c2\overline{c3}\overline{c4}, \overline{c2}\overline{c3}\overline{c4}, c5c6, \overline{c5}c6, c5\overline{c6}, \overline{c5}\overline{c6} \}$

    * $c1$：`i < str.length()`
    * $c2$：`!isLetter(str.charAt(i))`
    * $c3$：`last == 's'`
    * $c4$：`last == 'r'`
    * $c5$：`last == 'r'`
    * $c6$：`last == 's'`

  * 覆盖率：

    | 编号 | 测试用例                                                  | 覆盖元素                                       |
    | ---- | --------------------------------------------------------- | ---------------------------------------------- |
    | t1   | $\langle str = 'oranges\ and\ apples', words = 2 \rangle$ | $c1, \overline{c1}, c2c3\overline{c4}, \cdots$ |

* MC/DC覆盖
  * 覆盖域：

## 4.7 测试用例设计总结

* 等价类划分
* 边界值分析
* 覆盖率准则
  * 不同的软件等级选用不同的覆盖率准则
  * 覆盖率准则可用于评价测试用例集


## 4.8 练习

* 

